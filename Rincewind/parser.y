%require "3.2"
%language "c++"

%defines "parser.h"

%define api.namespace {yy}
%define api.parser.class {parser}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.error verbose
%locations

%code requires {
	#pragma warning(disable: 4065)	
	#include "../rincewind_statement.h"	
	#include "../rincewind_common.h"	
	#undef internal
	#undef function
	struct context;
	
	namespace yy {
		class lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
	}
}

%parse-param { yy::lexer& Lexer } 

%{
	#include <iostream>
	#include <cmath>	
	#include "../rincewind_context.h"
	#include "lex.yy.h"

	#undef yylex
	#define yylex Lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

%}

%token			END 0
				LABEL
				IDENTIFIER
				NUMCONST
				TEXT
				
%token
	CALL			"call"
	SCRIPT_BLOCK	"```"	
	STAR			"*"
	COLON			":"
	EQUAL			"="
	STICK			"|"
	DOLLAR			"$"		
	HYPHEN			"-"
	OPEN_PARENTH	"("
	CLOSE_PARENTH	")"
	OPEN_BRACKET	"["
	CLOSE_BRACKET	"]"	
	GREATER			">"
	LESS			"<"
	NOT				"~"

%type<string>	LABEL	
%type<string>	IDENTIFIER
%type<int>	NUMCONST
%type<string>	TEXT
%type<statement_type> condition_sign

%type<statement>  script_statement condition jump indirect_jump option script dialog statement
%type<parameters> options script_body statements

%start screenplay

%%
screenplay:		LABEL statements LABEL			{ Lexer.Ctx->AbstractTree = CreateCode($2); }
;

statements:		statements statement			{ $1.push_back($2); $$ = $1;											}
|				%empty							{ $$ = parameters();													}
;

statement:		dialog							{ $$ = $1;																}
|				jump							{ $$ = $1;																}
|				jump condition					{ $$ = CreateCondition($2, $1);											}
|				script							{ $$ = $1;																}
|				LABEL							{ $$ = CreateDefineLabel($1);											}
|				error							{ $$ = statement();														}
;

dialog:			"-" TEXT ":" TEXT				{ $$ = CreateDialog(CreateUniqueString($2), CreateString($4));			}
|				"-" TEXT ":" indirect_jump		{ $$ = CreateDialog(CreateUniqueString($2), $4); 						}
|				"-" TEXT ":" options			{ $$ = CreateDialogWithOptions(CreateUniqueString($2), $4); 			}
|				"-" TEXT ":" condition TEXT		{ $$ = CreateCondition($4, CreateDialog(CreateUniqueString($2), CreateString($5))); }
|				"-" TEXT ":" condition indirect_jump { $$ = CreateCondition($4, CreateDialog(CreateUniqueString($2), $5)); }
|				"-" TEXT ":" condition options	{ $$ = CreateCondition($4, CreateDialogWithOptions(CreateUniqueString($2), $5)); 	}
;

options:		options option					{ $1.push_back($2); $$ = $1;											}
|				option							{ $$ = {$1};															}
;

option:			"*" indirect_jump				{ $$ = CreateOption($2);												}
|				"*" TEXT						{ $$ = CreateOption(CreateString($2));									}
|				"*" indirect_jump condition		{ $$ = CreateCondition($3, CreateOption($2));							}
|				"*" TEXT condition				{ $$ = CreateCondition($3, CreateOption(CreateString($2)));				}
;

indirect_jump:	"[" TEXT "]" "(" LABEL ")"		{ $$ = CreateIndirectJump(CreateString($2), CreateLabel($5)); 			}
;

jump:			"[" TEXT "]" "(" LABEL ")"		{ $$ = CreateJump(CreateLabel($5)); 									}
;

script:			"```" script_body "```"			{ $$ = CreateCode($2); 													}
;

script_body:	script_body script_statement	{ $1.push_back($2); $$ = $1; 											}
|				script_statement				{ $$ = {$1};														 	}	
;

script_statement:	CALL TEXT					{ $$ = CreateCall($2);													}
;

condition:		"|" IDENTIFIER									{ $$ = CreateLogicalOperation(statement_type::NotEqual, CreateIdentifier($2), CreateNumber(0)); }
|				"|" "!" IDENTIFIER								{ $$ = CreateLogicalOperation(statement_type::Equal, CreateIdentifier($3), CreateNumber(0));	}
|				"|" IDENTIFIER condition_sign NUMCONST			{ $$ = CreateLogicalOperation($3, CreateIdentifier($2), CreateNumber($4)); 						}
|				"|" IDENTIFIER condition_sign IDENTIFIER		{ $$ = CreateLogicalOperation($3, CreateIdentifier($2), CreateIdentifier($4));					}
;

condition_sign:	">"								{ $$ = statement_type::Greater; 										}
|				"<"								{ $$ = statement_type::Less; 											}
|				">" "="							{ $$ = statement_type::GreaterOrEqual; 									}
|				"<" "="							{ $$ = statement_type::LessOrEqual; 									}
|				"="								{ $$ = statement_type::Equal; 											}
|				"~" "="							{ $$ = statement_type::NotEqual; 										}
;
%%

void yy::parser::error (const location_type& loc, const std::string& msg)
{
	Lexer.Ctx->ParsingErrors++;
	std::cout << "Syntax Error: (" << loc.begin.line << ", " << loc.begin.column << ") - " << msg << '\n';	
}
