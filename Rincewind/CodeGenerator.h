#pragma once
#include <string>
#include <map>
#include "rincewind_statement.h"

/**
 * Rincewind machine
 */

#define NO_JUMP "-2"

enum ERincewindRegisters {
	RR_FStringRegister,								// SR
	RR_FNameRegister,								// NR
	RR_IntRegister,									// IR
	RR_BoolRegister,								// BR

	// Memory
	RR_TemporalFStringRegister,						// TSR
	RR_TemporalFNameRegister,						// TNR
	RR_TemporalIntRegister,							// TIR
	RR_TemporalBoolRegister,						// TBR
};

enum ERincewindInstructionSet {
	RIS_None,
	// Register Instructions
	RIS_SetRegister,					// load xR X
	RIS_MoveRegister,					// mov (T)xR (T)xR

	// Process Instructions
	RIS_ProcessJump,					// jump IR
	RIS_ProcessJumpIf,					// jump IR BR			
	RIS_ProcessTitle,					// prc SR
	RIS_ProcessText,					// prc SR
	RIS_ProcessOption,					// prc SR IR
	RIS_WaitInteraction,				// wait
	RIS_WaitOptionSelection,			// wait
	RIS_CallFunction,					// call NR

	// Conditional Instructions
	RIS_LessThan,						// lt MIR IR			if (MIR < IR)
	RIS_LessOrEqual,					// le MIR IR			if (MIR <= IR)
	RIS_GreatThan,						// gt MIR IR			if (MIR > IR)
	RIS_GreatOrEqual,					// ge MIR IR			if (MIR >= IR)
	RIS_Equal,							// eq MIR IR			if (MIR == IR)
	RIS_NotEqual,						// neq MIR IR			if (MIR != IR)

	// Memory Instructions
	RIS_LoadRegister,					// load xR $Memory		BR true = global store

	RIS_StoreRegister,					// store BR NR MSR 		pending	      	BR true = global store

	/*
	 * Internal instructions, these instructions are not generated by the language, but by the interpreter
	 */
	RIS_INTERNAL_ProcessText,			// prc SR
	RIS_INTERNAL_UnloadSubroutine,		// unsbr

	RIS_INTERNAL_Delay,					// delay	
};


struct FRincewindStatement
{
	ERincewindInstructionSet Instruction;
	std::string FirstParam;
	std::string SecondParam;

	FRincewindStatement() : Instruction(ERincewindInstructionSet::RIS_None), FirstParam(""), SecondParam("") {}
	FRincewindStatement(ERincewindInstructionSet InInstruction, std::string InFirstParam = "", std::string InSecondParam = "") : Instruction(InInstruction), FirstParam(InFirstParam), SecondParam(InSecondParam) {}	

	std::string ToString()
	{		
		return std::to_string(Instruction) + " " + FirstParam + " " + SecondParam;
	}
};

class Context;

// TODO: Implement types
//TODO: Implement store and load
//TODO: Implement local and global storage!

/**
* This class takes the statements parsed and generates code machine for Rincewind. All the instructions are 3-address instruction type, so the interpreter is quite straight forward.
* the parsed statements will come as TStatements, that is just a vector<FStatement>. The entry point of this class is GenerateCode, uses the Context to fetch the Statements and start the process.
* There are two types of functions Generate* and Process*, all the Generate functions takes an FStatement and convert the statement into Rincewind code, or directly generates code without an statement.
* This is the case of WaitForOption, that is not an instruction written by the user in the source code, but is an instruction that will be generated automatically.
* The Process functions do not generates code, but prepares the code generator and sync the CodeContext with usefull information to proceed with the translation.
* 
*/

// class CodeGenerator
// {
// public:
// 	CodeGenerator() : ConditionalSequence(0)
// 	{
// 		CodeContext = nullptr;
// 	}
// 	CodeGenerator(Context* InContext);

// 	std::vector<FRincewindStatement> RincewindCode; //:)


// private:

// 	int ConditionalSequence;

// 	std::vector<int> LinesWithLabelProcessingPending;

// 	Context* CodeContext;

// 	void GenerateDialogCode(FStatement& Statement, bool bWithText);

// 	void GenerateOptionCode(FStatement& Statement);

// 	void GenerateWaitForOptionCode();

// 	void GenerateJumpCode(FStatement& Statement);

// 	void GenerateCallCode(FStatement& Statement);

// 	/**
// 	 * This function adds the label to the identifiers table in the CodeContex, so in the future, when ProcessJumpsSecondPass is called, the context will know which line represents
// 	 * this label
// 	 */
// 	void ProcessLabel(FStatement& Statement);

// 	std::string GenerateStoreContext(std::string& Alias);

// 	void GenerateCondition(FStatement& Statement);

// 	void ProcesFStatement(FStatement& Statement);	

// 	void GenerateCode(TStatements& Statemets);
	
// public:
// 	/**
// 	 * The first pass generating the code doesn't know which line represents each label, so, after generating all the code, we need to change the label with the real code line
// 	 */
// 	void ProcessJumpsSecondPass();

// 	void GenerateCode();
// };

