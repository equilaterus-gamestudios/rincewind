#pragma once
/// Project
#include "rincewind_statement.h"
#include "rincewind_context.h"
#include "rincewind_globals.h"



enum ERincewindRegisters {
	FStringRegister,								// SR
	FNameRegister,								// NR
	IntRegister,									// IR
	BoolRegister,								// BR

	// Memory
	TemporalFStringRegister,						// TSR
	TemporalFNameRegister,						// TNR
	TemporalIntRegister,							// TIR
	TemporalBoolRegister,						// TBR
};

enum ERincewindInstructionSet {
	None,
	// Register Instructions
	SetRegister,					// load xR X
	MoveRegister,					// mov (T)xR (T)xR

	// Process Instructions
	ProcessJump,					// jump IR
	ProcessJumpIf,					// jump IR BR			
	ProcessTitle,					// prc SR
	ProcessText,					// prc SR
	ProcessOption,					// prc SR IR
	WaitInteraction,				// wait
	WaitOptionSelection,			// wait
	CallFunction,					// call NR

	// Conditional Instructions
	LessThan,						// lt MIR IR			if (MIR < IR)
	LessOrEqual,					// le MIR IR			if (MIR <= IR)
	GreatThan,						// gt MIR IR			if (MIR > IR)
	GreatOrEqual,					// ge MIR IR			if (MIR >= IR)
	Equal,							// eq MIR IR			if (MIR == IR)
	NotEqual,						// neq MIR IR			if (MIR != IR)

	// Memory Instructions
	LoadRegister,					// load xR $Memory		BR true = global store

	StoreRegister,					// store BR NR MSR 		pending	      	BR true = global store

	/*
	 * Internal instructions, these instructions are not generated by the language, but by the interpreter
	 */
	INTERNAL_ProcessText,			// prc SR
	INTERNAL_UnloadSubroutine,		// unsbr

	INTERNAL_Delay,					// delay	
};


function void
TraverseAbstractTree (const statement* Statement)
{
	if (IsAtomStatement(Statement))
	{
		// Generate Code...
	}
	for(int i = 0; i < Statement->Parameters.size(); ++i)
	{
		const statement* Param = &Statement->Parameters[i];
		TraverseAbstractTree(Param);
	}

	switch (Statement->Type) {

        case statement_type::None:
        case statement_type::Number:
        case statement_type::String:
        case statement_type::Label:
        case statement_type::UniqueString:
        case statement_type::Identifier:
        case statement_type::Call:
		/// Trivial
        case statement_type::WaitOptionSelection:
        case statement_type::WaitInteraction:
		//////
        case statement_type::Dialog:
        case statement_type::DialogWithOptions:
        case statement_type::Option:
        case statement_type::Command:
        case statement_type::Jump:
        case statement_type::Condition:
		////// Trivial
        case statement_type::Code:
        case statement_type::Equal:
        case statement_type::NotEqual:
        case statement_type::Greater:
        case statement_type::GreaterOrEqual:
        case statement_type::Less:
        case statement_type::LessOrEqual:
                break;
        }
}