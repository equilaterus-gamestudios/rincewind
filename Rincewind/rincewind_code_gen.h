#pragma once

/// Project
#include "rincewind_globals.h"
#include "rincewind_context.h"
#include "rincewind_common.h"
#include "rincewind_resource.h"
#include <sys/types.h>


enum register_type {
	FStringRegister,								// SR	
	IntRegister,									// IR
	BoolRegister,									// BR
	FloatRegister,									

	// Memory
	TemporalFStringRegister,						// TSR	
	TemporalIntRegister,							// TIR
	TemporalBoolRegister,						// TBR
	TemporalFloatRegister
};

//NOTE(pipecaniza): to simplify the code gen no inmediate supported
enum instruction_type {
	None,
	// Register Instructions
	SetRegister,					// load xR X
	MoveRegister,					// mov (T)xR (T)xR

	// Memory Instructions
	LoadRegister,					// load xR $Memory		BR true = global store
	StoreRegister,					// store BR NR MSR 		pending	      	BR true = global store

	// Process Instructions
	ProcessJump,
	ProcessJumpIf,					// jump BR IR
	ProcessTitle,					// prc IR
	ProcessText,					// prc IR
	ProcessOption,					// prc IR X             if(BR) use X
	WaitInteraction,				// wait					
	WaitOptionInteraction,			// wait					
	CallFunction,					// call SR

	// Conditional Instructions
	LessThan,						// lt MIR IR			if (MIR < IR)
	LessOrEqual,					// le MIR IR			if (MIR <= IR)
	GreatThan,						// gt MIR IR			if (MIR > IR)
	GreatOrEqual,					// ge MIR IR			if (MIR >= IR)
	Equal,							// eq MIR IR			if (MIR == IR)
	NotEqual,						// neq MIR IR			if (MIR != IR)

	/*
	 * Internal instructions, these instructions are not generated by the language, but by the interpreter
	 */
	INTERNAL_ProcessText,			// prc SR
	INTERNAL_UnloadSubroutine,		// unsbr

	INTERNAL_Delay,					// delay	
};

struct instruction
{
	instruction_type Instruction;
	uint FirstParameter;
	uint SecondParameter;
};

inline internal
instruction MakeInstruction(instruction_type Instruction, int FirstParameter, int SecondParameter)
{
	instruction Result;
	Result.Instruction = Instruction;
	Result.FirstParameter = FirstParameter;
	Result.SecondParameter = SecondParameter;
	return(Result);
}

struct pending_label
{
	int InstructionIndex;
	string Label;
};

inline internal pending_label
MakePendingLabel(int InstructionIndex, const string& Label)
{
	pending_label Result;
	Result.InstructionIndex = InstructionIndex;
	Result.Label = Label;
	return(Result);
}

struct machine_code 
{
	uint8 Byte1;
	uint8 Byte2;
	uint8 Byte3;
};

inline internal machine_code
MakeMachineCode(uint I32)
{
	machine_code Result;
	Result.Byte1 = 0xFF & (I32 >> 16);
	Result.Byte2 = 0xFF & (I32 >> 8);
	Result.Byte3 = 0xFF & I32;
	return Result;
}

//TODO(pipecaniza): set this define
#define MAX_CODE_SIZE 10000
#define MAX_PENDING_LABELS 5000
#define MAX_AUTO_LABELS 5000
struct code_gen
{
	machine_code MachineCode[MAX_CODE_SIZE];
	int MachineCodeSize = 0;
	instruction Code[MAX_CODE_SIZE];
	int CodeSize = 0;
	context* Context;
	resource_container* Resource;

	std::unordered_map<char*, int> CacheLabels;
	pending_label PendingLabels[MAX_PENDING_LABELS];
	int PendingLabelsSize;

	char AutoLabels[MAX_AUTO_LABELS];
	char* AutoLabelsPtr;
};

inline internal void
PushInstruction(code_gen* CodeGen, instruction&& Instruction)
{
	CodeGen->Code[CodeGen->CodeSize++] = Instruction;
}

#define PushAndMakeInst(CG, it, p1, p2) PushInstruction(CG, MakeInstruction(it, p1, p2))

inline internal void 
AddLabel(code_gen* CodeGen, const string& Label)
{
	if (CodeGen->CacheLabels.count(Label.Data))
	{
		//NOTE(pipecaniza): duplicated labels
		++CodeGen->Context->GeneratingErrors;
		return;
	}
	CodeGen->CacheLabels.emplace(Label.Data, CodeGen->CodeSize);
}

inline internal void
AddPendingLabel(code_gen* CodeGen, const string& Label)
{
	CodeGen->PendingLabels[CodeGen->PendingLabelsSize++] = MakePendingLabel(CodeGen->CodeSize, Label);
}

inline internal string
AddPendingAutoLabel(code_gen* CodeGen)
{
	string Result = MakeString(CodeGen->AutoLabelsPtr++, 1);
	CodeGen->PendingLabels[CodeGen->PendingLabelsSize++] = MakePendingLabel(CodeGen->CodeSize, Result);
	return(Result);
}

/*
NOTE(pipecaniza):
1- How to deal with options jumps?, because they don´t execute the jump inmediately.
2- We need to deal with these resources: 
	a) unique strings(labels, titles). - Are we gona store the labels? - I don´t think so
	c) localization strings(text). These are the only ones that must have a readable format
	d) Non-localization strings(funcion calls, state identifiers) - inmediate data?
3- Are we going to precompute the labels with the memory code direction?
4- 5-bits instruction opcode. 4-bits registers....

	xxxx x|xxx x|xxx xxxx xxxx xxxx xxxx xxxx = 4 bytes

	4.194.304

5- How to deal with inmediate data?
	We can store all the atom types as resources. Yes, stream all inmediate data at the
	beginning of the compiled code.
6- How to handle audio files?

*/

inline internal int
AddAtomToResources(resource_container* Resource, const statement* AtomStatement)
{
	switch (AtomStatement->Type) 
	{
	case statement_type::String:
		return InsertLocalization(Resource, AtomStatement->StrValue);
	case statement_type::Number:
		return InsertInmediateNumberData(Resource, AtomStatement->NumericValue);	
	case statement_type::UniqueString:
		return InsertNonLocalizationData(Resource, AtomStatement->StrValue);
	case statement_type::Identifier:
	case statement_type::Call:
		return InsertInmediateStringData(Resource, AtomStatement->StrValue);
	default:
		return -1;
	}
}

inline internal instruction_type
GetLogicalOp(const statement* Statement)
{
	switch (Statement->Type) 
	{
        case statement_type::Equal: return instruction_type::Equal;
        case statement_type::NotEqual: return instruction_type::NotEqual;
        case statement_type::Greater: return instruction_type::GreatThan;
        case statement_type::GreaterOrEqual: return instruction_type::GreatOrEqual;
        case statement_type::Less: return instruction_type::LessThan;
        case statement_type::LessOrEqual: return instruction_type::LessOrEqual;
		default: return instruction_type::None;
	}
}

//TODO(pipecaniza): use load inst
#define NONE 0
#define FALSE 0
#define TRUE 1
internal void
GenerateInstructions(code_gen* CodeGen, const statement* Statement)
{
	switch (Statement->Type) 
	{
		case statement_type::DefineLabel: 
			AddLabel(CodeGen, Statement->StrValue);
			break;
		case statement_type::Label:
			AddPendingLabel(CodeGen, Statement->StrValue);
			break;
		case statement_type::String:		
		case statement_type::UniqueString:
			PushAndMakeInst(CodeGen, instruction_type::SetRegister, register_type::IntRegister, AddAtomToResources(CodeGen->Resource, Statement));
			break;
		//TODO(pipecaniza): handle non numeric identifiers
		//NOTE(pipecaniza): in read-only we store identifier number, how to load the idenfier?
		//					maybe if (BR) use SR else X from read-only?
		case statement_type::Identifier:
		case statement_type::Number:
			PushAndMakeInst(CodeGen, instruction_type::LoadRegister, register_type::FloatRegister, AddAtomToResources(CodeGen->Resource, Statement));
			break;
        case statement_type::Call:			
			PushAndMakeInst(CodeGen, instruction_type::LoadRegister, register_type::FStringRegister, AddAtomToResources(CodeGen->Resource, Statement));
			PushAndMakeInst(CodeGen, instruction_type::CallFunction, NONE, NONE);
			break;
        case statement_type::Dialog:
			GenerateInstructions(CodeGen, &Statement->Parameters[0]);
			PushAndMakeInst(CodeGen, instruction_type::ProcessTitle, NONE, NONE);			
			GenerateInstructions(CodeGen, &Statement->Parameters[1]);
			PushAndMakeInst(CodeGen, instruction_type::ProcessText, NONE, NONE);
			PushAndMakeInst(CodeGen, instruction_type::WaitInteraction, NONE, NONE);		
			break;
        case statement_type::DialogWithOptions:
			GenerateInstructions(CodeGen, &Statement->Parameters[0]);
			PushAndMakeInst(CodeGen, instruction_type::ProcessTitle, NONE, NONE);
			for (int i = 1; i < Statement->Parameters.size(); ++i) {
				GenerateInstructions(CodeGen, &Statement->Parameters[i]);
			}			
			PushAndMakeInst(CodeGen, instruction_type::WaitOptionInteraction, NONE, NONE);
			break;
        case statement_type::Option:
			PushAndMakeInst(CodeGen, instruction_type::SetRegister, register_type::BoolRegister, FALSE);
			GenerateInstructions(CodeGen, &Statement->Parameters[0]);
			PushAndMakeInst(CodeGen, instruction_type::ProcessOption, NONE, NONE);   
			break;
        case statement_type::Jump:
			//TODO(pipecaniza): process labels			
			PushAndMakeInst(CodeGen, instruction_type::SetRegister, register_type::IntRegister, NONE);
			PushAndMakeInst(CodeGen, instruction_type::ProcessJump, NONE, NONE);
			break;
		case statement_type::IndirectJump:
		PushAndMakeInst(CodeGen, instruction_type::SetRegister, register_type::BoolRegister, TRUE);
			PushAndMakeInst(CodeGen, instruction_type::SetRegister, register_type::TemporalIntRegister, NONE);
			break;
        case statement_type::Condition:			
		{
			GenerateInstructions(CodeGen, &Statement->Parameters[0]);
			string PendingAutoLabel = AddPendingAutoLabel(CodeGen);
			PushAndMakeInst(CodeGen, instruction_type::SetRegister, register_type::IntRegister, NONE);
			PushAndMakeInst(CodeGen, instruction_type::ProcessJumpIf, NONE, NONE);
			GenerateInstructions(CodeGen, &Statement->Parameters[1]);
			AddLabel(CodeGen, PendingAutoLabel);
			break;			
		}
        case statement_type::Code:
			for (auto& Param: Statement->Parameters) {
				GenerateInstructions(CodeGen, &Param);
			}
			break;
        case statement_type::Equal:	//TODO(pipecaniza): implement strings and bool comparison
        case statement_type::NotEqual:			
        case statement_type::Greater:
		case statement_type::GreaterOrEqual:
		case statement_type::Less:
		case statement_type::LessOrEqual:
			GenerateInstructions(CodeGen, &Statement->Parameters[1]);
			PushAndMakeInst(CodeGen, instruction_type::MoveRegister, register_type::FloatRegister, register_type::TemporalFloatRegister);
			GenerateInstructions(CodeGen, &Statement->Parameters[0]);
			PushAndMakeInst(CodeGen, GetLogicalOp(Statement), register_type::FloatRegister, register_type::TemporalFloatRegister);
			break;
			default: return;
	}
}

internal void
ProcessLabels(code_gen* CodeGen)
{
	for (int i = 0; i < CodeGen->PendingLabelsSize; ++i) 
	{
		const pending_label& PendingLabel = CodeGen->PendingLabels[i];
		assert(PendingLabel.InstructionIndex < CodeGen->CodeSize);
		assert(CodeGen->CacheLabels.count(PendingLabel.Label.Data));
		CodeGen->Code[PendingLabel.InstructionIndex].SecondParameter = CodeGen->CacheLabels[PendingLabel.Label.Data];
	}
}

function void
GenerateCode (code_gen* CodeGen)
{
	GenerateInstructions(CodeGen, &CodeGen->Context->AbstractTree);
	ProcessLabels(CodeGen);
}

//NOTE(pipecaniza): max memory pos 2²³
// xxxx xxxx xxxx xxxx xxxx xxxx


function void
GenerateMachineCode(code_gen* CodeGen)
{
	for (int i = 0; i < CodeGen->CodeSize; ++i) 
	{
		const instruction& Instruction = CodeGen->Code[i];
		uint MachineInstruction = ((uint)Instruction.Instruction & 0x1f) < 19 | 
								(Instruction.FirstParameter & 0x7) < 16 |
								(Instruction.SecondParameter & 0x7fffff);
		CodeGen->MachineCode[CodeGen->MachineCodeSize++] = MakeMachineCode(MachineInstruction);
	}
}

inline function void
ExportCode(code_gen* CodeGen, FILE* File)
{
	fwrite(CodeGen->MachineCode, sizeof(machine_code), CodeGen->MachineCodeSize, File);
}