%require "3.2"
%language "c++"

%defines "parser.h"

%define api.namespace {yy}
%define api.parser.class {parser}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.error verbose
%locations

%code requires {
	#pragma warning(disable: 4065)	
	#include "../rincewind_statement.h"	
	#undef internal
	#undef function
	struct context;
	
	namespace yy {
		class lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
	}
}

%parse-param { yy::lexer& Lexer } 

%{
	#include <iostream>
	#include <cmath>	
	#include "../rincewind_context.h"

	#undef yylex
	#define yylex Lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

	//#define A Lexer.Ctx->Arena

%}

%token			END 0
				LABEL
				IDENTIFIER
				NUMCONST
				TEXT
				
%token
	CALL			"call"
	SCRIPT_BLOCK	"```"
	AND				"&&"	
	OR				"||"
	STAR			"*"
	COLON			":"
	EQUAL			"="
	STICK			"|"
	DOLLAR			"$"		
	HYPHEN			"-"
	OPEN_PARENTH	"("
	CLOSE_PARENTH	")"
	OPEN_BRACKET	"["
	CLOSE_BRACKET	"]"	
	GREATER			">"
	LESS			"<"
	NOT				"~"
	HIGHLIGHT		"`"

%left "&&"
%left "||"

%type<string>	LABEL	
%type<string>	IDENTIFIER
%type<int>	NUMCONST
%type<string>	TEXT
%type<statement_type> condition_sign

%type<statement>  script_statement condition jump indirect_jump option script dialog statement localization_text exp exp_def exp_el
%type<parameters> options script_body statements

%start screenplay

%%
screenplay:		LABEL statements LABEL			{ 
													$2.insert($2.begin(), CreateDefineLabel($1));
													$2.push_back(CreateDefineLabel($3));
													Lexer.Ctx->AbstractTree = CreateCode($2); 
												}
;

statements:		statements statement			{ $1.push_back($2); $$ = $1;											}
|				%empty							{ $$ = parameters();													}
;

statement:		dialog							{ $$ = $1;																}
|				jump							{ $$ = $1;																}
|				jump condition					{ $$ = CreateCondition($2, $1);											}
|				script							{ $$ = $1;																}
|				LABEL							{ $$ = CreateDefineLabel($1);											}
|				error							{ $$ = statement();														}
;

dialog:			"-" TEXT ":" localization_text			{ $$ = CreateDialog(CreateNonLocalizationString($2), $4);									}
|				"-" TEXT ":" indirect_jump				{ $$ = CreateDialog(CreateNonLocalizationString($2), $4); 									}
|				"-" TEXT ":" options					{ $$ = CreateDialogWithOptions(CreateNonLocalizationString($2), $4); 						}
|				"-" TEXT ":" condition localization_text{ $$ = CreateCondition($4, CreateDialog(CreateNonLocalizationString($2), $5)); 				}
|				"-" TEXT ":" condition indirect_jump 	{ $$ = CreateCondition($4, CreateDialog(CreateNonLocalizationString($2), $5)); 				}
|				"-" TEXT ":" condition options			{ $$ = CreateCondition($4, CreateDialogWithOptions(CreateNonLocalizationString($2), $5)); 	}
;

options:		options option					{ $1.push_back($2); $$ = $1;											}
|				option							{ $$ = {$1};															}
;

option:			"*" indirect_jump				{ $$ = CreateOption($2);												}
|				"*" localization_text			{ $$ = CreateOption($2);												}
|				"*" indirect_jump condition		{ $$ = CreateCondition($3, CreateOption($2));							}
|				"*" localization_text condition	{ $$ = CreateCondition($3, CreateOption($2));							}
;

indirect_jump:	"[" TEXT "]" "(" LABEL ")"				{ $$ = CreateIndirectJump(CreateLocalizationString($2, {}), CreateLabel($5)); 						}
|				"[" TEXT "]" "(" LABEL ")" "`" TEXT "`" { $$ = CreateIndirectJump(CreateLocalizationString($2, CreateAudio($8)), CreateLabel($5)); 			}
;

jump:			"[" TEXT "]" "(" LABEL ")"		{ $$ = CreateJump(CreateLabel($5)); 									}
;

localization_text:	TEXT "`" TEXT "`"			{ $$ = CreateLocalizationString($1, CreateAudio($3));					}
|					TEXT						{ $$ = CreateLocalizationString($1, {}); 								}
;

script:			"```" script_body "```"			{ $$ = CreateCode($2); 													}
;

script_body:	script_body script_statement	{ $1.push_back($2); $$ = $1; 											}
|				script_statement				{ $$ = {$1};														 	}	
;

script_statement:	CALL TEXT					{ $$ = CreateCall($2);													}
;

condition:		"|" "`" exp "`"					{ $$ = $3;																}
;

exp:			exp_def							{ $$ = $1; 																}
|				"(" exp ")"						{ $$ = $2;								 								}
|				exp "||" exp					{ $$ = CreateLogicalOperation(statement_type::Or, $1, $3); 				}
|				exp "&&" exp					{ $$ = CreateLogicalOperation(statement_type::And, $1, $3); 			}
;

exp_def:		exp_el condition_sign exp_el	{ $$ = CreateComparison($2, $1, $3); 										}
|				exp_el							{ $$ = CreateComparison(statement_type::NotEqual, $1, CreateNumber(0)); 	}
|				"!" exp_el						{ $$ = CreateComparison(statement_type::Equal, $2, CreateNumber(0));		}
;

exp_el:			IDENTIFIER						{ $$ = CreateIdentifier($1); 											}
|				NUMCONST						{ $$ = CreateNumber($1); 												}
;

condition_sign:	">"								{ $$ = statement_type::Greater; 										}
|				"<"								{ $$ = statement_type::Less; 											}
|				">" "="							{ $$ = statement_type::GreaterOrEqual; 									}
|				"<" "="							{ $$ = statement_type::LessOrEqual; 									}
|				"="								{ $$ = statement_type::Equal; 											}
|				"~" "="							{ $$ = statement_type::NotEqual; 										}
;
%%

void yy::parser::error (const location_type& loc, const std::string& msg)
{
	Lexer.Ctx->ParsingErrors++;
	printf("Syntax error: (%d, %d) - %s\n", loc.begin.line, loc.begin.column, msg.c_str());
}
